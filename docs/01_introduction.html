<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.21">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introduction – Data Science Project</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Data Science Project</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./01_introduction.html" aria-current="page"> 
<span class="menu-text">Introduction</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-dataprepeda" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">DataPrep/EDA</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-dataprepeda">    
        <li>
    <a class="dropdown-item" href="./02_01_overview.html">
 <span class="dropdown-text">Overview</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./02_02_data_gathering_and_cleaning.html">
 <span class="dropdown-text">Data Gathering and Data Cleaning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./02_03_data_visualization.html">
 <span class="dropdown-text">Data Visualization</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-modelmethod" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Model/Method</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-modelmethod">    
        <li>
    <a class="dropdown-item" href="./03_clustering.html">
 <span class="dropdown-text">Clustering</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./04_pca.html">
 <span class="dropdown-text">Principal Component Analysis (PCA)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./05_naive_bayes.html">
 <span class="dropdown-text">Naïve Bayes</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./06_decision_trees.html">
 <span class="dropdown-text">Decision Trees</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./07_svm.html">
 <span class="dropdown-text">Support Vector Machine (SVM)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./08_regression.html">
 <span class="dropdown-text">Regression</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./09_nn.html">
 <span class="dropdown-text">Neural Network (NN)</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="./10_conclusions.html"> 
<span class="menu-text">Conclusions</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/taso5789/ds-project-portfolio"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/taihei-sone-586102253/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#backgrounds" id="toc-backgrounds" class="nav-link active" data-scroll-target="#backgrounds">Backgrounds</a></li>
  <li><a href="#research-questions" id="toc-research-questions" class="nav-link" data-scroll-target="#research-questions">Research Questions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Introduction</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="justify">
<p>Notes: All images displayed on this page are free-use materials, unless otherwise indicated by a specific credit.</p>
</div>
<section id="backgrounds" class="level1">
<h1>Backgrounds</h1>
<div class="justify">
<ul>
<li>The relationship between inflation and unemployment has long constituted a central issue in the field of macroeconomics. These two indicators are not merely statistical constructs but rather fundamental determinants that directly affect the standard of living of households and the overall stability of society. Inflation reflects the purchasing power of money and exerts a profound influence on the decision-making processes of households and firms, while unemployment represents the state of labor market conditions and is closely associated with household income and the productive capacity of the economy. Historically, the evolution of these two variables has frequently posed conflicting challenges for policymakers. For example, expansionary policies may succeed in reducing unemployment in the short run, yet they simultaneously raise the likelihood of accelerating inflation. Conversely, policies aimed at containing inflation often depress aggregate demand, thereby heightening the risk of increased unemployment. Thus, reconciling the goals of price stability and full employment has consistently been a central concern in both economic theory and policy practice. The U.S. Federal Reserve’s explicit commitment to a “dual mandate” of price stability and maximum employment exemplifies this tension. Moreover, this dual mandate extends beyond considerations of economic efficiency alone, carrying critical implications for social cohesion and political stability. An uncontrolled surge in inflation can undermine household welfare and destabilize everyday life, while persistently elevated unemployment can exacerbate inequality, fuel political unrest, and highlight the need for a comprehensive theoretical and empirical understanding of their dynamics for effective policy.</li>
</ul>
</div>
<div class="columns">
<div class="column" style="width:50%;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig_01_intro_01.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
</div><div class="column" style="width:50%;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig_01_intro_02.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
</div>
</div>
<div class="justify">
<ul>
<li>As a classical contribution to this theme, <a href="https://www.jstor.org/stable/2550759" target="_blank">Phillips (1958)</a> demonstrated the existence of a stable negative correlation between wage growth and the unemployment rate, thereby presenting the important insight that the balance of supply and demand in the labor market is directly linked to wage fluctuations. His study was based on long-term data from the United Kingdom, but the result came to be regarded as a general phenomenon observable in many countries. Subsequently, <a href="https://www.jstor.org/stable/1815021" target="_blank">Samuelson and Solow (1960)</a>, through an empirical study using U.S. data, generalized Phillips’s finding into a trade-off relationship between inflation and unemployment, emphasizing the possibility of applying this relationship to economic policy and suggesting that policymakers could “choose” a desirable combination of the two. This interpretation had a major impact on macroeconomic policy debates at the time, but the stability of the relationship was questioned early on, and a series of theoretical objections soon emerged. <a href="https://www.jstor.org/stable/1909635" target="_blank">Muth (1961)</a>, with the rational expectations hypothesis, challenged the traditional adaptive expectations framework by assuming that agents form expectations consistent with the underlying economic model. Furthermore, <a href="https://www.jstor.org/stable/1830921" target="_blank">Sargent and Wallace (1975)</a> advanced the policy ineffectiveness proposition, arguing that anticipated monetary policy has no lasting impact on real economic activity, and <a href="https://www.sciencedirect.com/science/article/pii/S0167223176800036" target="_blank">Lucas (1976)</a> added the critique that statistically observed macroeconomic relationships may shift depending on the prevailing policy rule. These arguments highlighted the limitations of using the Phillips curve directly for policy purposes and led to the understanding that there is no sustained long-run trade-off between inflation and unemployment, with the unemployment rate converging to its natural rate. At the same time, since the neoclassical framework assuming perfectly flexible prices could not sufficiently explain short-run business cycle fluctuations, the need for more realistic models increased. Against this background, New Keynesian models such as the price adjustment cost model by <a href="https://www.journals.uchicago.edu/doi/10.1086/261117" target="_blank">Rotemberg (1982)</a> and the stochastic price-setting model by <a href="https://www.sciencedirect.com/science/article/abs/pii/0304393283900600" target="_blank">Calvo (1983)</a> emerged, demonstrating that by explicitly incorporating nominal rigidities, a short-run trade-off between inflation and unemployment could indeed exist. These models were subsequently systematized by <a href="https://press.princeton.edu/books/hardcover/9780691010496/interest-and-prices?srsltid=AfmBOooL-mQcyVMMtJDNbvYTzvPuyvaw9SQphjUa6VVjQVCC20weMjAZ" target="_blank">Woodford (2003)</a>, forming the standard theoretical foundation of modern monetary policy analysis and becoming widely referenced in the practice of central banking.</li>
</ul>
</div>
<div class="text-center">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig_01_intro_03.jpg" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Source: <a href="https://www.wallstreetmojo.com/phillips-curve/" target="_blank">WallStreetMojo</a></figcaption>
</figure>
</div>
</div>
<div class="justify">
<ul>
<li>On the empirical side, the strength and stability of the relationship between inflation and unemployment have consistently been a subject of debate. In particular, recent studies indicate that the Phillips curve does not function as a fixed empirical regularity but rather changes its shape depending on the historical period and economic environment. <a href="https://www.elibrary.imf.org/view/journals/001/2011/121/article-A001-en.xml" target="_blank">Ball and Mazumder (2011)</a>, using U.S. data, reported a flattening of the Phillips curve and demonstrated that the impact of unemployment fluctuations on inflation has weakened substantially compared to the past. This finding is consistent with the anchoring of inflation expectations and the increased credibility of monetary policy, and it has been recognized as a factor contributing to the stability of inflation. <a href="https://www.jstor.org/stable/43860981" target="_blank">Blanchard (2016)</a> focused on U.S. inflation dynamics and emphasized that, unlike in earlier periods, changes in unemployment no longer move inflation rates as strongly, making it more difficult for policymakers to rely on the Phillips curve. Furthermore, <a href="https://www.nber.org/papers/w25987" target="_blank">Stock and Watson (2019)</a> showed that the predictability of U.S. inflation has declined markedly in recent years and concluded that traditional Phillips curve–based forecasting models fail to deliver sufficient accuracy. <a href="https://academic.oup.com/qje/article/137/3/1299/6529257" target="_blank">Hazell et al.&nbsp;(2022)</a>, using state-level panel data, provided empirical evidence that the relationship between inflation and unemployment changes nonlinearly depending on whether the economy is subject to demand or supply shocks. Their research is important in that it highlights how relationships that appear blurred in aggregate macroeconomic data can become more clearly identifiable at the regional level. Taken together, this body of work suggests that the Phillips curve does not simply operate as a stable relationship in which “lower unemployment leads to higher inflation,” but instead varies significantly depending on economic conditions, the nature of shocks, and policy regimes. Therefore, analyzing the relationship between inflation and unemployment requires a flexible approach that goes beyond reliance on static empirical regularities and takes into account institutional contexts and the characteristics of shocks.</li>
</ul>
</div>
<div class="text-center">
<p><img src="images/fig_01_intro_04.jpg" class="img-fluid" style="width:50.0%"></p>
</div>
<div class="justify">
<ul>
<li>In recent years, with the advancement of machine learning, there has been a rapid increase in attempts to apply data-driven methods to the forecasting of key macroeconomic variables such as inflation and unemployment. These methods have attracted attention because they offer the potential to capture nonlinearities and complex interdependencies that traditional linear regression and time-series models fail to detect. <a href="https://doi.org/10.1080/07350015.2019.1637745" target="_blank">Medeiros et al.&nbsp;(2021)</a>, using U.S. inflation data, employed Random Forests and Least Absolute Shrinkage and Selection Operator (LASSO) in their analysis and reported predictive accuracy superior to that of conventional AutoRegressive (AR) and factor models, thereby demonstrating that machine learning can hold an advantage over traditional approaches. This study provided results directly relevant to improving inflation forecasts used in practice by central banks and other policymakers, underscoring its empirical significance. Furthermore, <a href="https://onlinelibrary.wiley.com/doi/10.1002/for.2824?af=R&amp;msockid=15a4a2166a2a623a02bab4236bf363c6" target="_blank">Gogas et al.&nbsp;(2021)</a> examined unemployment in the euro area as a whole and compared machine learning techniques with traditional time-series models, showing that machine learning has an advantage in short-term forecasting. They found that while Random Forests and Support Vector Machines (SVMs) achieve higher prediction accuracy, challenges remain regarding model interpretability and policy applicability, highlighting the difficulty of applying machine learning directly to policy operations. This issue points to a fundamental challenge in macroeconomic research—namely, how to balance predictive accuracy with theoretical consistency and policy relevance. In addition, <a href="https://www.sciencedirect.com/science/article/pii/S0161893824001546" target="_blank">Magazzino et al.&nbsp;(2025)</a> analyzed unemployment across 23 advanced economies using artificial neural networks and demonstrated that factors such as GDP, labor productivity, demographic dynamics, and even AI-driven technological innovation are major determinants of unemployment fluctuations. Their results suggest that unemployment dynamics depend not only on cyclical factors but also heavily on structural and technological elements. Taken together, these studies underscore that while machine learning has proven effective for forecasting macroeconomic variables, they also highlight the need to overcome challenges related to model transparency and practical policy applicability.</li>
</ul>
</div>
<div class="text-center">
<p><img src="images/fig_01_intro_05.png" class="img-fluid" style="width:50.0%"></p>
</div>
<div class="justify">
<ul>
<li>However, important challenges remain in this line of research. First, much of the existing literature has focused on either inflation or unemployment in isolation, and there are relatively few attempts to analyze both variables in an integrated manner and systematically capture their interactions. In fact, although inflation and unemployment should be considered simultaneously from both theoretical and policy perspectives, many empirical studies have tended to concentrate on only one side. Second, while many studies emphasize the evaluation of predictive accuracy, frameworks that combine regime classification with regression-based forecasting have not been sufficiently developed. For example, only a limited number of studies identify regimes such as high- and low-inflation periods or recessions and expansions, and then evaluate predictive performance within each of these states. Third, much of the data used are drawn from commercial databases or restricted sources, which imposes constraints on transparency and reproducibility, although the use of open data could create an environment in which a broader range of researchers and policymakers can more easily replicate and extend results. Few studies, however, have explicitly incorporated this consideration. Fourth, the linear regression models that continue to play a central role in policy analysis, such as Ordinary Least Squares (OLS) and Vector Auto Regressive (VAR), are rarely compared directly with machine learning methods within a unified framework. This lack of comparison has limited the perspective needed for policymakers to understand how traditional and modern methods might be used in a complementary fashion, and the absence of such evaluations represents a major obstacle to assessing the practical applicability of machine learning in real-world policy contexts. Therefore, future research must adopt a more comprehensive approach that addresses not only predictive accuracy but also interpretability and policy relevance at the same time.</li>
</ul>
</div>
<div class="text-center">
<p><img src="images/fig_01_intro_06.png" class="img-fluid" style="width:50.0%"></p>
</div>
<div class="justify">
<ul>
<li>Based on the foregoing discussion, the objectives of this study can be organized into four main points. First, it aims to conduct an integrated analysis of inflation and unemployment by comparing traditional regression models (OLS, VAR, Elastic Net) with machine learning techniques (Naïve Bayes, decision trees, SVM, and neural networks) within a unified framework, thereby evaluating both predictive accuracy and interpretability. Second, it seeks to identify macroeconomic regimes through clustering and principal component analysis, and to apply classification and regression approaches in an integrated manner so as to examine simultaneously “where the economy currently stands” and “how it is likely to evolve.” Third, it will systematically analyze the dynamic causal relationship and regime dependence between inflation and unemployment using Granger causality tests and local projection methods. Fourth, by utilizing open and reproducible data sources such as the FRED API, the BLS API, and the World Bank API, the study aims to ensure transparency and reproducibility of the analysis and to provide a research platform that can be replicated and extended by a broad range of readers, including academic researchers and policymakers. Through these four pillars, this study aspires to bridge traditional research on the Phillips curve with contemporary machine learning approaches, thereby offering a new understanding of the relationship between inflation and unemployment. In addition, the study emphasizes not only the re-examination of existing findings but also the direct comparison between machine learning and regression analysis, with the explicit goal of deriving practical implications for policy applications. In light of this, the study sets forth 10 research questions designed to reconsider the relationship between inflation and unemployment from multiple perspectives, beginning with the existence of a short-run trade-off and expanding to assess regime dependence and the role of macroeconomic factors. Furthermore, by comparing the predictive performance and interpretability of machine learning and traditional models, they also delve into the causal direction of the relationship and the dynamic effects of shocks. Accordingly, this study seeks to provide a systematic framework that comprehensively addresses both theoretical and empirical challenges.</li>
</ul>
</div>
<div class="text-center">
<p><img src="images/fig_01_intro_07.png" class="img-fluid" style="width:50.0%"></p>
</div>
</section>
<section id="research-questions" class="level1">
<h1>Research Questions</h1>
<div class="justify">
<ol type="1">
<li><p>Is a short-run trade-off between inflation and unemployment statistically observable?</p></li>
<li><p>To what extent does the Phillips curve relationship vary across business-cycle phases (recessions and expansions) and policy regimes (e.g., the zero lower bound period or the COVID-19 era)?</p></li>
<li><p>How do macroeconomic factors extracted through principal component analysis (PCA) affect the dynamics of inflation and unemployment?</p></li>
<li><p>Does regime identification based on data-driven clustering align with historical episodes such as stagflation or the post–global financial crisis recovery?</p></li>
<li><p>To what extent can simple classification models such as Naïve Bayes and decision trees accurately identify periods of high inflation or high unemployment?</p></li>
<li><p>Does the support vector machine (SVM) improve regime-classification accuracy compared with simpler classifiers such as Naïve Bayes and decision trees?</p></li>
<li><p>How do traditional regression models (OLS, VAR, Elastic Net) and machine learning models (SVM, neural networks) differ in their performance when forecasting inflation and unemployment one, three, and six months ahead?</p></li>
<li><p>Can performance differences across forecasting models be judged statistically significant using tests such as the Diebold–Mariano test?</p></li>
<li><p>According to Granger causality tests, what is the causal direction between inflation and unemployment (inflation → unemployment or unemployment → inflation)?</p></li>
<li><p>Through local projection analysis, how do demand shocks and supply shocks dynamically affect inflation and unemployment?</p></li>
</ol>
</div>
<div class="columns">
<div class="column" style="width:33%;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig_01_intro_08.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%"></p>
</figure>
</div>
</div><div class="column" style="width:33%;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig_01_intro_10.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%"></p>
</figure>
</div>
</div><div class="column" style="width:33%;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/fig_01_intro_09.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%"></p>
</figure>
</div>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/taso5789\.github\.io\/ds-project-portfolio\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>